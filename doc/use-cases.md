Перед действиями нужно создать несколько переменных окружения:

PGP_KEY_PATH - путь, где хранится ключ шифрования.

PGP_REPO - репозиторий.

PGP_BRANCH - ветка.

# Выдача хелпа.

`dp-b -h` или `pg-p --help` - выдает хелп.

# Генерация ключа шифрования.

`pg-p gen-key`

* Проверяет PGP_KEY_PATH, если её нет - ругается и выходит.
* Если ключ существует - ругается и выходит.
* Если нет - сохраняет ключ по пути, указанному в PGP_KEY_PATH.

После этого надо положить файлик с ключом куда-то на машину и сохранить путь в PGP_KEY_PATH.

# Добавление пресета на amazon.

Определяешь системную переменную PGP_KEY_PATH 

`pg-p add repo=r-vision branch=4.1-test name=my-preset` 

Что происходит:

* Проверки на аргументы и переменные окружения.
* Проверка, что на amazon s3 нет такого файла. Есть есть - ругнуться и выйти.
* pg_dumpall -h 127.0.0.1 -U postgres --clean > <tmp директория внутри самого модуля>
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* криптование симметричным ключом.
* заливка на amazon S3

# Обновление пресета на amazon.

`pg-p upd repo=r-vision branch=4.1-test name=my-preset` 

Что происходит:

* Проверки на аргументы и переменные окружения.
* Проверка, что на amazon s3 есть такой файл. Есть нет - ругнуться и выйти.
* pg_dumpall -h 127.0.0.1 -U postgres --clean > <tmp директория внутри самого модуля>
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* криптование симметричным ключом.
* заливка на amazon S3

# Установка новой машины для тестирования.

`dp-p init repo=r-vision branch=4.1-test`

Что происходит:

* Проверяем, что на amazon есть такая директория. Если нет - ругаемся и выходим.
* Создается папка /opt/pg-presets/<repo>/<branch> 
* Создается папка /opt/pg-presets-data/<repo>/<branch> 
* В папку стягиваются все зашифрованные файлы xz из amazon.
* Расшифровываются.
* Раз-zx-уются.
* И дальше в цикле накатываются (psql -h 127.0.0.1 -U postgres -f script), сохраняются в pg-presets-data с помощью pg_basebackup.






