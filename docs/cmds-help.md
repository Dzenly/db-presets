# Список команд с подробным описанием их действий.

## Установка переменных окружения

См. [переменные окружения](env-vars.md)

## Выдача хелпа

`db-p` или `dp-b -h` - выдает хелп, включая описание переменных окружения.

--------------

## Добавление нового пресета

`db-p add name=<preset-name> creator=<user-name> desc=<preset-description>`

### Шаги:

* Проверки аргументов и переменных окружения.
* Проверка что локально нет такого файла, если есть ругнуться, предложить "update" и выйти.
* Проверка, что на Amazon S3 нет такого файла. Есть есть - ругнуться и выйти.
* `pg_dumpall -h 127.0.0.1 -U postgres --clean > <директория для sql дампов>`
в папку с пресетами.
* Приtarивание к файлу лога изменений в той же временной папке.
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* криптование симметричным ключом.
* заливка на amazon S3.
* Сохранение бинарного пресета с помощью pg_basebackup.
* Пометка во внутреннем файле, что выбран пресет `<preset-name>` и `clean` у него `true`.

### Результат:

* Заполнены внутренние директории для sql пресета, changelog файла, бинарного пресета.
* Текущее состояние БД сохранено на Amazon S3 в виде нового зашифрованного пресета.
* Внутри объекта - два файла: пресет и текстовый файл с логом изменений, в который занесен description.

### Замечания

* Алгоритм неустойчив, если два человека одинаковый пресет в один момент времени решили создать.

--------------

## Генерация ключа шифрования (только один раз всех пресетов для одной ветки)

`db-p gen-key`

#### Шаги:

* Проверяет переменную окружения DBP_AESKEY_PATH, если её нет - ругается и выходит.
* Если ключ существует - ругается и выходит.
* Если нет, генерит ключ  и сохраняет его по пути, указанному в DBP_AESKEY_PATH.

#### Результат:

В системе лежит ключ шифрования.

#### Замечания

* Для одного Amazon S3 "ведра", эта команда выполняется один раз.
Если нужно наладить систему на другой машине - нужно скопировать этот ключ на все машины.

--------------

## Стянуть все пресеты для заданного репозитория и ветки.

`db-p get [only=name1,name2,...]`

### Шаги:

* Если есть параметр `only`, убеждается, что все пресеты из `only` есть на Amazon S3.
* Останавливается приложение.
* Делается `aws s3 sync`, и на локальную машину стягиваются либо все, либо указанные в `only`
пресеты из Amazon S3, которые изменились. Т.е. если какие-то пресеты у вас уже есть,
они тянуться не будут.
* Эти новые или изменившиеся файлы расшифровываются.
* Раз-zx-уются.
* И дальше в цикле по всем пресетам накатываются (`psql -h 127.0.0.1 -U postgres -f name`),
накатываются миграции, сохраняются бинарные пресеты с помощью `pg_basebackup`.
* Команда выполняется таким образом, что последний пресет из указанных в `only`,
или в стянутых из Amazon S3 (если `only` не задали), оказывается актуальным.
* Во внутренних данных запоминается выбранный пресет, и у него проставляется флаг `clean`,
означающий, что с ним ещё не работали в тестах.

### Результат:

* Приложение остановлено.
* В системе есть все пресеты, в том числе в виде бинарных данных, чтобы можно было быстро переключаться между ними.

### Замечания:

* При совместной работе время от времени важно делать `get`, чтобы подкачивать изменения других.
* Особенно это важно при редактировании пресетов. Команда `set-lock` завершится с ошибкой, если
на Amazon S3 есть пресет свежее, чем на вашей машине.

--------------

## Блокировка пресета на запись на Amazon S3.

`db-p set-lock name=<preset-name> locker=my-name desc=<description>`

### Шаги / Результат:

* Проверка есть ли файл с локом. Если да, ругнуться и выйти.
* Проверка не заблочен ли уже на amazon. Если да, то выводится кем когда зачем заблокирован.
* Генерится рандомный lock-key.
* В метаданные объекта на Amazon S3 заносится инфа, что объект заблочен, автор и причина, а также lock-key.
* Возвращается `lock-key`, который нужно юзать при перезаписи пресета.
* Во внутреннюю директорию сохраняется файлик presetName.lock.json, который содержит:
автора, причину, `lock-key`.

### Замечания

* Брать файл на запись нужно после того, как поставил лок на него.

--------------

## Посмотреть какие есть пресеты для заданных (в [переменных окружения](env-vars.md) ) репозитория и ветки.

`db-p ls where=(local | s3) [short]`

* where - local - из локальной директории, s3 - на Amazon S3.
* short - краткая форма (без указаания дат и размеров).
Работает только для where === s3.


### Шаги

* Если where === local - просто читаем директорию с архивами пресетов и выдаем содержимое.
* Если where === s3 - запрашивает содержимое корзины с Amazon S3.

--------------

## Проверка блокировки пресета на запись на amazon S3.

`db-p get-lock name=my-preset`

### Шаги / Результат:

* Выводится инфа, кто когда и зачем заблокировал.
* Если блокировали на вашей машине, выводится и `lock-key`.

--------------

## Сброс блокировки пресета на запись на amazon S3.

`db-p reset-lock name=preset-name key=my-key`

### Шаги / результат

* Снимается лок, если ты передумал редактировать пресет.

### Замечания.

* Нужно взять ключ у того, кто залочил. Если забыли ключ, можно посмотреть в логах, или на крайняк в GUI Amazon S3.
* Лок снимается автоматически при `push-ex`.
--------------

## Обновление существующего пресета на amazon (после редактирования)

`db-p update name=my-preset key=my-key updater=my-name desc=description`

### Шаги:

* Проверки на аргументы и переменные окружения.
* Проверка, что у тебя есть такой лок файл.
* Проверка, что на amazon s3 есть такой файл. Есть нет - ругнуться и выйти.
* Проверка, что на файле стоит лок и lock-key совпадает. Если лока нет или не совпадает - ругнуться и выйти.
* `pg_dumpall -h 127.0.0.1 -U postgres --clean > <tmp директория внутри самого модуля>`
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* приtarивание к логу изменений.
* криптование симметричным ключом.
* заливка на amazon S3.
* Снятие лока на amason S3.
* Удаление локального лока.

### Результат:

* Предыдущая версия сохранена в amazon S3. И может быть восстановлена, в случае если с пресетом накосячили.
* Для корзины установлены политики устаревания, дней в 10, после которых считается, что пресет проверен,
и старые версии хранить не надо, чтобы экономить место и деньги.
* Текущее состояние БД сохранено на amazon S3 в виде текущей версии существующего пресета.
* Лог изменений в самом верху содержит описание изменения.

### Замечания

* Если забыл поставить лок. Есть шанс поставить его задним числом,
если никто его не поставил, и если с тех пор как ты взял файл - он не менялся.


--------------

## Выбор пресета

`db-p select name=my-preset clean url`

### Что происходит:

* Если не проставлен clean, и текущий пресет совпадает с запрашиваемым, завершаем действие без ошибок.
* Останавливается приложение.
* Если PostgreSQL работает, он останавливается.
* Делается rsync нужной директории из `/opt/db-presets/**/*` в DBP_PG_DATA_DIR.
* Запускается PostgreSQL.
* Запускается приложение.

--------------

## Перезалив с другим ключом шифрования ?? (TODO)

--------------

?? Удаление объектов ??

init ?

* Проверяем, что на amazon есть .
* Создается (если не было) папка $DBP_PRESETS_DIR.
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/arc` (архивы).
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/sql` (sql скрипты).
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/data` (бинарная data).


what-selected

TODO: все занести в кратких хелп.

При апдейте, что если у тебя старый.
Нужно обязательно подтягивать новый.

При локе проверить sync, если будет output - ругнуться и попросить сначала сделать get only=preset.

Команда для старта и ожидания приложения?