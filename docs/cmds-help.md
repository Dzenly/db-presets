# Список команд с подробным описанием их действий.


## Установка переменных окружения

[Почитать об этом можно тут](env-vars.md)


## Выдача хелпа

`dp-b -h` или `db-p --help` - выдает хелп, включая описание переменных окружения.

--------------

## Генерация ключа шифрования (только один раз всех пресетов для одной ветки)

`db-p gen-key`

### Шаги:

* Проверяет DBP_AESKEY_PATH, если её нет - ругается и выходит.
* Если ключ существует - ругается и выходит.
* Если нет - сохраняет ключ по пути, указанному в DBP_KEY_PATH.

### Результат:

В системе лежит ключ шифрования.

### Замечания

Можно выполнять эту команду только один раз.
А потом копировать существующий ключ на разные машины.
Но теоретически, каждая ветка в каждом репозитории может иметь свою ключ шифрования.
Для секюрности, имеет какой-то смысл для новых веток генерить новый ключ.

--------------

## Посмотреть какие есть пресеты для заданного репозитория и ветки.

`db-p ls`

### Шаги

* Вызываем `aws s3`

## Стянуть все пресеты для заданного репозитория и ветки

`db-p pull [include=name1,name2] [exclude=name3,name4] [select=name]`

`select` можно не задавать, если include содержит один пресет.

### Шаги:

* Проверяем, что на amazon есть такая директория. Если нет - ругаемся и выходим.
* Создается (если не было) папка $DBP_PRESETS_DIR.
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/arc` (архивы).
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/sql` (sql скрипты).
* Создается (если не было) папка `$DBP_PRESETS_DIR/<repo>/<branch>/data` (бинарная data).
* Останавливается приложение (AUT).
* В папку стягиваются все (с учетом include/exclude) зашифрованные файлы xz из amazon,
  которые не существуют в папке, или изменились.
* Эти новые или изменившиеся файлы расшифровываются.
* Раз-zx-уются.
* И дальше в цикле по всем пресетам накатываются (`psql -h 127.0.0.1 -U postgres -f name`),
накатываются миграции, сохраняются в db-presets-data с помощью pg_basebackup.
* Останавливается PostgreSQL.

### Результат:

В тестовой системе мы имеем остановленное приложение, остановленный PostgreSQL.
И все снапшоты PG data директорий, с накаченными миграциями.

### Замечания:

Нужно делать перед каждым запуском. Т.к. пресеты кто-то мог поменять. Эти изменения должны подхватиться.

--------------

## Добавление пресета на amazon (после создания)

`db-p push-new name=my-preset creator=my-name desc=description`

### Шаги:

* Проверки на аргументы и переменные окружения.
* Проверка что локально нет такого файла, если есть ругнуться, предложить push-ex и выйти.
* Проверка, что на amazon s3 нет такого файла. Есть есть - ругнуться и выйти.
* `pg_dumpall -h 127.0.0.1 -U postgres --clean > <tmp директория внутри самого модуля>`
в папку с пресетами.
* Приtarивание к файлу лога изменений в той же временной папке.
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* криптование симметричным ключом.
* заливка на amazon S3.
* Очистка временной папки.

### Результат:

* Текущее состояние БД сохранено на amazon S3 в виде нового зашифрованного пресета.
* Внутри объекта - два файла: пресет и текстовый файл с логом изменений, в который занесен description (изменения писать в форме: кто: что_за_изменения).

### Замечания

* Файлы в /opt/db-presets остаются в необновленном состоянии.
* Если продолжить редактировать, и сохранить новую версию, все будет ок,
т.к. последняя сохраненная и находится в БД.
* Чтобы их обновить нужно `db-p pull-and-update-local ...`.

* Алгоритм неустойчив, если два автора одинаковый пресет в один момент времени решили создать.

### TODO:

* Кейс, когда сначала поредактировали один пресет. Сохранили.
Накатили другой. Сохранили. Потребует обновления после каждого наката.
Если такое надо будет поддержать, то потом.

--------------

## Блокировка пресета на запись на amazon S3.

`db-p set-lock name=my-preset who=my-name desc=description`

### Шаги / Результат:

* Проверка есть ли файл с локом. Если да, ругнуться и выйти.
* Проверка не заблочен ли уже на amazon. Если да, то выводится кем когда зачем заблокирован.
* В метаданные объекта на Amazon S3 заносится инфа, что объект заблочен, автор и причина, а также lock-key.
* Возвращается `lock-key`, который нужно юзать при перезаписи пресета.
* Во внутреннюю директорию сохраняется файлик presetName.lock.json, который содержит:
автора, причину, lock-key.

### Замечания

* Брать файл на запись нужно после того, как поставил лок на него.

--------------

## Проверка блокировки пресета на запись на amazon S3.

`db-p get-lock name=my-preset`

### Шаги / Результат:

* Выводится инфа, кто когда и зачем заблокировал.
* Если блокировали на вашей машине, выводится и `lock-key`.

--------------

## Сброс блокировки пресета на запись на amazon S3.

`db-p reset-lock name=my-preset lock-key=my-key`

### Шаги / результат

* Снимается лок, если ты передумал редактировать пресет.

### Замечания.

* Лок снимается автоматически при `push-ex`.
--------------

## Обновление существующего пресета на amazon (после редактирования)

`db-p push-ex name=my-preset lock-key=my-key desc=description`

### Шаги:

* Проверки на аргументы и переменные окружения.
* Проверка, что у тебя есть такой лок файл.
* Проверка, что на amazon s3 есть такой файл. Есть нет - ругнуться и выйти.
* Проверка, что на файле стоит лок и lock-key совпадает. Если лока нет или не совпадает - ругнуться и выйти.
* `pg_dumpall -h 127.0.0.1 -U postgres --clean > <tmp директория внутри самого модуля>`
* xz файла (кол-во потоков = кол-ву процессоров, уровень сжатия - максимальный)
* приtarивание к логу изменений.
* криптование симметричным ключом.
* заливка на amazon S3.
* Снятие лока на amason S3.
* Удаление локального лока.

### Результат:

* Предыдущая версия сохранена в amazon S3. И может быть восстановлена, в случае если с пресетом накосячили.
* Для корзины установлены политики устаревания, дней в 10, после которых считается, что пресет проверен,
и старые версии хранить не надо, чтобы экономить место и деньги.
* Текущее состояние БД сохранено на amazon S3 в виде текущей версии существующего пресета.
* Лог изменений в самом верху содержит описание изменения.

### Замечания

* Если забыл поставить лок. Есть шанс поставить его задним числом,
если никто его не поставил, и если с тех пор как ты взял файл - он не менялся.


--------------

## Выбор пресета

`db-p select preset-name clean=yes`

### Что происходит:

* Если не проставлен clean, и текущий пресет совпадает с запрашиваемым, завершаем действие без ошибок.
* Если PostgreSQL работает, он останавливается.
* Делается rsync нужной директории из `/opt/db-presets/**/*` в DBP_PG_DATA_DIR.
* Запускается PostgreSQL.
* Запускается приложение.

--------------

## Перезалив с другим ключом шифрования ?? (TODO)

--------------

?? Удаление объектов ??
